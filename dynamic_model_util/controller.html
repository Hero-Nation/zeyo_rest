<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>컨트롤러 시뮬레이터</title>
<script src="https://code.jquery.com/jquery-3.3.1.min.js" integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=" crossorigin="anonymous"></script>
<script src="svg.js"></script>
<script>
	var imported_dm = imported_dm || {};
	var current_zip_dm = null;
	var current_control_data = null;

	var MAIN_CANVAS = null;

	var import_model = function() {

		if (MAIN_CANVAS != null) {
			MAIN_CANVAS.clear();
		} else {
			MAIN_CANVAS = SVG('MAIN_CANVAS');
		}

		imported_dm = $("#input_dm").val();
		imported_dm = $.trim(imported_dm);

		if (imported_dm == "") {
			alert("수치 모델을 입력해주세요!");
			return;
		}

		imported_dm = JSON.parse(imported_dm);
		draw_model(imported_dm);

	};

	var find_center_xy = function(p_dm) {

		var max_x = 0;
		var max_y = 0;

		for ( var unit_index in p_dm.component) {

			var this_e = p_dm.component[unit_index];

			if (this_e.start.x > max_x) {
				max_x = this_e.start.x;
			}

			if (this_e.end.x > max_x) {
				max_x = this_e.end.x;
			}

			if (this_e.start.y > max_y) {
				max_y = this_e.start.y;
			}

			if (this_e.end.y > max_y) {
				max_y = this_e.end.y;
			}

		}

		return {
			x : max_x / 2,
			y : max_y / 2
		};
	}

	var move_center = function() {

		var center_x = $("#center_x").val();
		var center_y = $("#center_y").val();
		var center_ratio = $("#center_ratio").val();

		if (center_x == null) {
			alert("새로운 중심점 X 값을 넣어주세요!");
			return;
		}

		if (center_y == null) {
			alert("새로운 중심점 Y 값을 넣어주세요!");
			return;
		}

		if (center_ratio == null) {
			alert("새로운 비율 값을 넣어주세요!");
			return;
		}

		var move_gap = {};

		move_gap.x = center_x - imported_dm.center.x;
		move_gap.y = center_y - imported_dm.center.y;

		var center = {
			x : center_x,
			y : center_y
		};

		var clone_dm = $.extend(true, {}, imported_dm);

		for ( var component_index in clone_dm.component) {
			var component = clone_dm.component[component_index];
			var moved_component = move_component(component, move_gap);
			clone_dm.component[component_index] = scale_component_data(center,
					moved_component, center_ratio);
		}

		clone_dm.center = center;
		clone_dm.ratio = center_ratio;

		zip_model(clone_dm);
	};

	var draw_model = function(p_dynamic_model) {

		MAIN_CANVAS.clear();

		var component_data = p_dynamic_model.component;

		for ( var component_index in component_data) {

			var component = component_data[component_index];

			var flat_data = flat_component(component);

			if (component.type == "path") {

				var path = MAIN_CANVAS.path(flat_data);
				path.fill('none');
				path.stroke({
					color : '#60f',
					width : 2,
					linecap : 'round',
					linejoin : 'round'
				});

			} else if (component.type == "line") {

				var line = MAIN_CANVAS.line(flat_data).stroke({
					color : '#f06',
					width : 2
				});

			}
		}

	};

	var get_point_by_ratio2_test = function() {

		MAIN_CANVAS = SVG('MAIN_CANVAS');

		var p_center = {
			x : 30,
			y : 50
		};

		var p_original_point = {
			x : 0,
			y : 0
		};

		/*
		x1 : 10.00
		controller.html:246 y1 : 50.00
		controller.html:247 x2 : 0.00
		controller.html:248 y2 : 0.00
		controller.html:249 두점의 길이 : 50.99019513592785
		controller.html:250 비율만큼 늘어난 길이 : 101.98
		controller.html:251 비율만큼 늘어난 길이의 제곱 : 10399.00
		controller.html:401 기울기 : 5
		controller.html:411 a : 26
		controller.html:412 b : 480
		controller.html:413 c : -7799
		controller.html:429 eq_x1 : 10.39
		controller.html:430 eq_y1 : 51.95
		controller.html:431 eq_x2 : -28.86
		controller.html:432 eq_y2 : -144.3
		controller.html:452 execution time : 9 ms
		
		
		 */
		/*
		
		
		var p_center = {
			x : 0,
			y : 0
		}; 
		
		var p_original_point = { 	
			x : 30,
			y : 50
		}; 
		
		

		
		x1 : 0.00
		controller.html:245 y1 : 0.00
		controller.html:246 x2 : 10.00
		controller.html:247 y2 : 50.00
		controller.html:248 두점의 길이 : 50.99019513592785
		controller.html:249 비율만큼 늘어난 길이 : 101.98
		controller.html:250 비율만큼 늘어난 길이의 제곱 : 10399.00
		controller.html:400 기울기 : 5
		controller.html:410 a : 26
		controller.html:411 b : 0
		controller.html:412 c : -10399
		controller.html:428 eq_x1 : 20.00
		controller.html:429 eq_y1 : 100
		controller.html:430 eq_x2 : -20.00
		controller.html:431 eq_y2 : -100
		controller.html:451 execution time : 9 ms
		
		
		
		 */

		var p_ratio = 2;

		/* 		var p_original_point = {
		 x : -120,
		 y : 130
		 };
		
		 var p_original_point = {
		 x : -120,
		 y : -130
		 };
		
		 var p_original_point = {
		 x : 120,
		 y : -130
		 };
		 */

		var d = new Date();
		var start = d.getMilliseconds();

		var target_x = null;
		var target_y = null;

		//console.log("시작점 ");
		//console.log(p_center);

		//console.log("끝점 ");
		//console.log(p_original_point);

		//console.log("비율 ");
		//console.log(p_ratio);

		// scale 적용전의 두점을 거리를 구한다.

		var original_length = distants_on_two_point(p_center, p_original_point);

		// scale이 적용된 거리

		var scale_length = original_length * p_ratio;
		scale_length = scale_length.toFixed(2);
		var scale_length_pow = Math.floor(scale_length * scale_length);
		scale_length_pow = scale_length_pow.toFixed(2);

		var x1 = Number(p_center.x).toFixed(2);
		var y1 = Number(p_center.y).toFixed(2);

		var x2 = Number(p_original_point.x).toFixed(2);
		var y2 = Number(p_original_point.y).toFixed(2);

		//console.log("x1 : " + x1);
		//console.log("y1 : " + y1);
		//console.log("x2 : " + x2);
		//console.log("y2 : " + y2);
		//console.log("두점의 길이 : " + original_length);
		//console.log("비율만큼 늘어난 길이 : " + scale_length);
		//console.log("비율만큼 늘어난 길이의 제곱 : " + scale_length_pow);

		/*
		
		방정식 1 
		
			eq_y = ( ( y2 - y1 ) / ( x2 - x1 ) ) * ( eq_x - x1 ) + y1;
		
		방정식 2
		
			(eq_x - x1) * (eq_x - x1) + (eq_y - y1) *  (eq_y - y1) - scale_length_pow = 0;
		
		
		근의 공식
		
		    ax2 + bx + c = 0 ;
		
		 */

		var a = 0;
		var b = 0;
		var c = 0;
		var eq_y = 0;

		var eq_x1 = 0;
		var eq_x2 = 0;

		var eq_y1 = 0;
		var eq_y2 = 0;

		if (x2 == x1) {

			/*
			
			 * 방정식 1 
			
			ex_x = x1;
			
			
			 * 방정식 2
			
			
			eq_y * eq_y - 2 * y1 * eq_y + y1 * y1 = 0
			
			
			 * 근의 공식 변수
			
			a = 1 ;
			
			b = -2 * y1;
			
			c = y1 * y1 - scale_length_pow;
			
			 */

			a = 1;

			b = -2 * y1;

			c = y1 * y1 - scale_length_pow;

			eq_x1 = x1;
			eq_x1 = x2;

			//console.log("a : " + a);
			//console.log("b : " + b);
			//console.log("c : " + c);

			eq_y1 = (-b + Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_y1 = Number(eq_y1).toFixed(2);
			eq_y2 = (-b - Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_y2 = Number(eq_y2).toFixed(2);

		} else {

			/*
			
			 
			
			방정식 1 
			
				eq_y = ( ( y2 - y1 ) / ( x2 - x1 ) ) * ( eq_x - x1 ) + y1;
			
			
			기울기
			
				var eq1_slope = (y2 - y1)/(x2 - x1);
			
			
				eq_y = eq1_slope * (eq_x - x1) + y1;
				
				eq_y = eq1_slope * eq_x - eq1_slope * x1 + y1;
			
			
			방정식 2
			
				(eq_x - x1) * (eq_x - x1) + (eq_y - y1) * (eq_y - y1) - scale_length_pow = 0;
			
			-------------------------------------------------------------------------------------------------------------------------------------------------------
			
			(eq_y - y1) * (eq_y - y1) 	   수식 풀이 버전 1
			   
			   
			
			eq_y - y1 = eq1_slope * eq_x - eq1_slope * x1 + y1 - y1 ;
			
			eq_y - y1 = eq1_slope * eq_x - eq1_slope * x1;
			
			   
			(eq1_slope * eq_x - eq1_slope * x1 ) * (eq1_slope * eq_x - eq1_slope * x1 ) 
			
			
			= eq1_slope * eq_x * eq1_slope * eq_x     -     2 * eq1_slope * x1 * eq1_slope * eq_x      +       eq1_slope * x1 * eq1_slope * x1
			
			= eq1_slope * eq1_slope * eq_x * eq_x     -     2 * eq1_slope * eq1_slope * x1 * eq_x      +       eq1_slope * eq1_slope * x1 * x1
			
			
			~~~~~~~~~~~~~~~~~~
			
			
			(eq_x - x1) * (eq_x - x1) + (eq_y - y1) * (eq_y - y1)
			
			
			= eq_x * eq_x                               -     2 * x1 * eq_x                                +       x1 * x1 
			
			+ eq1_slope * eq1_slope * eq_x * eq_x       -     2 * eq1_slope * eq1_slope * x1 * eq_x        +       eq1_slope * eq1_slope * x1 * x1
			
			
			= (1 +  eq1_slope * eq1_slope)(eq_x * eq_x) - 2 * (x1 + eq1_slope * eq1_slope * x1 ) * eq_x  + ( 1 + eq1_slope * eq1_slope)( x1 * x1);
			   
			
				a = (1 +  eq1_slope * eq1_slope);
				b = -2 * x1 -2 * eq1_slope * eq1_slope * x1 
				c = (1 + eq1_slope * eq1_slope)(x1 * x1);
			
			
			근의 공식
			
			    ax2 + bx + c = 0 ;
			
			 */

			var eq1_slope = (y2 - y1) / (x2 - x1);

			//console.log("기울기 : " + eq1_slope);

			a = 1 + eq1_slope * eq1_slope;

			b = -2 * x1 - 2 * eq1_slope * eq1_slope * x1;

			c = x1 * x1 + eq1_slope * eq1_slope * x1 * x1 - scale_length_pow;

			//console.log("a : " + a);
			//console.log("b : " + b);
			//console.log("c : " + c);

			eq_x1 = (-b + Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_x1 = Number(eq_x1).toFixed(2);
			eq_x2 = (-b - Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_x2 = Number(eq_x2).toFixed(2);

			var eq1_slope = (y2 - y1) / (x2 - x1);

			eq_y1 = (eq1_slope * eq_x1) - (eq1_slope * x1) + Number(y1);
			eq_y2 = (eq1_slope * eq_x2) - (eq1_slope * x1) + Number(y1);

		}

		//console.log("eq_x1 : " + eq_x1);
		//console.log("eq_y1 : " + eq_y1);
		//console.log("eq_x2 : " + eq_x2);
		//console.log("eq_y2 : " + eq_y2);

		var center_axis_gap = 400;
		var circle_size = 6;

		var center_svg = MAIN_CANVAS.circle(circle_size).fill('red').move(
				Number(p_center.x) + Number(center_axis_gap),
				Number(p_center.y) + Number(center_axis_gap));
		var original_point_svg = MAIN_CANVAS.circle(circle_size).fill('blue')
				.move(Number(p_original_point.x) + Number(center_axis_gap),
						Number(p_original_point.y) + Number(center_axis_gap));
		var ratio_point_1_svg = MAIN_CANVAS.circle(circle_size).fill('green')
				.move(Number(eq_x1) + Number(center_axis_gap),
						Number(eq_y1) + Number(center_axis_gap));
		var ratio_point_2_svg = MAIN_CANVAS.circle(circle_size).fill('black')
				.move(Number(eq_x2) + Number(center_axis_gap),
						Number(eq_y2) + Number(center_axis_gap));

		var d = new Date();
		var end = d.getMilliseconds();

		//console.log("execution time : " + (end - start) + " ms");

	}

	var circle_test = function() {

		MAIN_CANVAS = SVG('MAIN_CANVAS');
		MAIN_CANVAS.clear();

		var center = {
			x : 390,
			y : 390
		};
		var rect1 = MAIN_CANVAS.rect(10, 10).fill("red");
		var rect2 = MAIN_CANVAS.rect(10, 10).fill("blue");

		var path = MAIN_CANVAS
				.path(" M 100, 100  m -75, 0  a 75,75 0 1,0 150,0 a 75,75 0 1,0 -150,0");

		//var path = MAIN_CANVAS.path("M0,100 Q50,-50 100,100 T200,100");
		//var path = MAIN_CANVAS.path("M17,42 L117,42 V142 H17 Z");
		//var path = MAIN_CANVAS.path("M 100 260 T 105 121 T 280 330 Z");
		path.center(center.x, center.y);
		var length = path.length()

		path.fill('none').stroke({
			width : 1,
			color : '#ccc'
		})

		var duration = 10000;
		var ratio = 0;
		var error_scope = 2;

		var count = 0;

		var max_x = 0;
		var min_x = 0;

		var sum_x = 0;
		var avg_x = 0;

		var max_y = 0;
		var min_y = 0;

		var sum_y = 0;
		var avg_y = 0;

		path.animate(duration).during(function(pos, morph, eased) {

			count++;

			var target = path.pointAt(eased * length);

			var new_position = get_point_by_extension(center, target, ratio);

			var tx = ((new_position.x - target.x) / ratio);
			var ty = ((new_position.y - target.y) / ratio);

			if (tx == 0) {
				ratio -= 0.1;
			}
			rect1.center(target.x, target.y);
			rect2.center(new_position.x, new_position.y);

		}).loop();

	}

	var get_point_by_ratio = function(p_center, p_original_point, p_ratio) {

		var target_x = null;
		var target_y = null;

		// scale 적용전의 두점을 거리를 구한다.

		var original_length = distants_on_two_point(p_center, p_original_point);

		// scale이 적용된 거리

		var scale_length = original_length * p_ratio;
		scale_length = scale_length.toFixed(2);
		var scale_length_pow = Math.floor(scale_length * scale_length);
		scale_length_pow = scale_length_pow.toFixed(2);

		var x1 = Number(p_center.x).toFixed(2);
		var y1 = Number(p_center.y).toFixed(2);

		var x2 = Number(p_original_point.x).toFixed(2);
		var y2 = Number(p_original_point.y).toFixed(2);

		var a = 0;
		var b = 0;
		var c = 0;
		var eq_y = 0;

		var eq_x1 = 0;
		var eq_x2 = 0;

		var eq_y1 = 0;
		var eq_y2 = 0;

		if (x2 == x1) {

			a = 1;

			b = -2 * y1;

			c = y1 * y1 - scale_length_pow;

			eq_x1 = x1;
			eq_x1 = x2;

			eq_y1 = (-b + Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_y1 = Number(eq_y1).toFixed(2);
			eq_y2 = (-b - Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_y2 = Number(eq_y2).toFixed(2);

		} else {

			var eq1_slope = (y2 - y1) / (x2 - x1);

			a = 1 + eq1_slope * eq1_slope;

			b = -2 * x1 - 2 * eq1_slope * eq1_slope * x1;

			c = x1 * x1 + eq1_slope * eq1_slope * x1 * x1 - scale_length_pow;

			eq_x1 = (-b + Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_x1 = Number(eq_x1).toFixed(2);
			eq_x2 = (-b - Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_x2 = Number(eq_x2).toFixed(2);

			var eq1_slope = (y2 - y1) / (x2 - x1);

			eq_y1 = (eq1_slope * eq_x1) - (eq1_slope * x1) + Number(y1);
			eq_y2 = (eq1_slope * eq_x2) - (eq1_slope * x1) + Number(y1);

		}

		if (x2 >= x1) {
			return {
				x : Number(Number(eq_x1).toFixed(2)),
				y : Number(Number(eq_y1).toFixed(2))
			};
		} else {
			return {
				x : Number(Number(eq_x2).toFixed(2)),
				y : Number(Number(eq_y2).toFixed(2))
			};
		}

	}

	var get_point_by_extension = function(p_center, p_original_point,
			p_extension) {
		console
				.log("-------------------------------------------------------------------------");
		console.log("       get_point_by_extension");
		console
				.log("-------------------------------------------------------------------------");
		console.log("       p_center");
		console.dir(p_center);
		console.log("       p_original_point");
		console.dir(p_original_point);
		console.log("       p_extension");
		console.dir(p_extension);

		var target_x = null;
		var target_y = null;

		// scale 적용전의 두점을 거리를 구한다.

		var original_length = distants_on_two_point(p_center, p_original_point);
		console.log("       original_length");
		console.dir(original_length);
		// scale이 적용된 거리

		var scale_length = original_length + p_extension;
		scale_length = scale_length.toFixed(2);
		var scale_length_pow = Math.floor(scale_length * scale_length);
		scale_length_pow = scale_length_pow.toFixed(2);

		var x1 = Number(p_center.x).toFixed(2);
		var y1 = Number(p_center.y).toFixed(2);

		var x2 = Number(p_original_point.x).toFixed(2);
		var y2 = Number(p_original_point.y).toFixed(2);

		var a = 0;
		var b = 0;
		var c = 0;
		var eq_y = 0;

		var eq_x1 = 0;
		var eq_x2 = 0;

		var eq_y1 = 0;
		var eq_y2 = 0;

		if (x2 == x1) {

			a = 1;

			b = -2 * y1;

			c = y1 * y1 - scale_length_pow;

			eq_x1 = x1;
			eq_x1 = x2;

			eq_y1 = (-b + Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_y1 = Number(eq_y1).toFixed(2);
			eq_y2 = (-b - Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_y2 = Number(eq_y2).toFixed(2);

		} else {

			var eq1_slope = (y2 - y1) / (x2 - x1);

			a = 1 + eq1_slope * eq1_slope;

			b = -2 * x1 - 2 * eq1_slope * eq1_slope * x1;

			c = x1 * x1 + eq1_slope * eq1_slope * x1 * x1 - scale_length_pow;

			eq_x1 = (-b + Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_x1 = Number(eq_x1).toFixed(2);
			eq_x2 = (-b - Math.sqrt(b * b - (4 * a * c))) / (2 * a);
			eq_x2 = Number(eq_x2).toFixed(2);

			var eq1_slope = (y2 - y1) / (x2 - x1);

			eq_y1 = (eq1_slope * eq_x1) - (eq1_slope * x1) + Number(y1);
			eq_y2 = (eq1_slope * eq_x2) - (eq1_slope * x1) + Number(y1);

		}

		console.log("       eq_x1");
		console.dir(eq_x1);
		console.log("       eq_y1");
		console.dir(eq_y1);
		console.log("       eq_x2");
		console.dir(eq_x2);
		console.log("       eq_y2");
		console.dir(eq_y2);

		if (x2 >= x1) {
			return {
				x : Number(Number(eq_x1).toFixed(2)),
				y : Number(Number(eq_y1).toFixed(2))
			};
		} else {
			return {
				x : Number(Number(eq_x2).toFixed(2)),
				y : Number(Number(eq_y2).toFixed(2))
			};
		}
	}

	var distants_on_two_point = function(p_point1, p_point2) {

		var x1 = Number(p_point1.x);
		var y1 = Number(p_point1.y);

		var x2 = Number(p_point2.x);
		var y2 = Number(p_point2.y);

		var d = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
		return Math.sqrt(d);
	};

	var scale_component_data = function(p_center, p_component, p_ratio) {

		var component_clone = $.extend(true, {}, p_component);

		component_clone.start = get_point_by_ratio(p_center,
				component_clone.start, p_ratio);
		component_clone.start.name = p_component.start.name;

		component_clone.end = get_point_by_ratio(p_center, component_clone.end,
				p_ratio);
		component_clone.end.name = p_component.end.name;

		var data = component_clone.data;

		for ( var component_index in data) {

			var step_data = data[component_index];

			if (component_clone.type == "path") {

				if (component_index == 0) {

					var p_target = {
						x : step_data[1],
						y : step_data[2]
					};

					p_target = get_point_by_ratio(p_center, p_target, p_ratio);

					step_data[1] = p_target.x;
					step_data[2] = p_target.y;

				} else {

					if (step_data[0] == "L") {

						var p_target = {
							x : step_data[1],
							y : step_data[2]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.x;
						step_data[2] = p_target.y;

					} else if (step_data[0] == "H") {

						var p_target = {
							x : step_data[1],
							y : component_clone.start.y
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.x;

					} else if (step_data[0] == "V") {

						var p_target = {
							x : component_clone.start.x,
							y : step_data[1]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.y;

					} else if (step_data[0] == "C") {

						var p_target = {
							x : step_data[1],
							y : step_data[2]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.x;
						step_data[2] = p_target.y;

						p_target = {
							x : step_data[3],
							y : step_data[4]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[3] = p_target.x;
						step_data[4] = p_target.y;

						p_target = {
							x : step_data[5],
							y : step_data[6]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[5] = p_target.x;
						step_data[6] = p_target.y;

					} else if (step_data[0] == "S") {

						var p_target = {
							x : step_data[1],
							y : step_data[2]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.x;
						step_data[2] = p_target.y;

						p_target = {
							x : step_data[3],
							y : step_data[4]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[3] = p_target.x;
						step_data[4] = p_target.y;

					} else if (step_data[0] == "Q") {

						var p_target = {
							x : step_data[1],
							y : step_data[2]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.x;
						step_data[2] = p_target.y;

						p_target = {
							x : step_data[3],
							y : step_data[4]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[3] = p_target.x;
						step_data[4] = p_target.y;

					} else if (step_data[0] == "T") {

						var p_target = {
							x : step_data[1],
							y : step_data[2]
						};

						p_target = get_point_by_ratio(p_center, p_target,
								p_ratio);

						step_data[1] = p_target.x;
						step_data[2] = p_target.y;

					} else if (step_data[0] == "A") {
						//console.log("A _____");
					} else if (step_data[0] == "Z") {
						//console.log("A _____");
					}

					//R += " ";
					//R += "z";
				}

			} else if (component_clone.type == "line") {

				if (component_index == 0) {

					var p_target = {
						x : step_data[1],
						y : step_data[2]
					};

					p_target = get_point_by_ratio(p_center, p_target, p_ratio);

					step_data[1] = p_target.x;
					step_data[2] = p_target.y;

				} else {

					var p_target = {
						x : step_data[1],
						y : step_data[2]
					};

					p_target = get_point_by_ratio(p_center, p_target, p_ratio);

					step_data[1] = p_target.x;
					step_data[2] = p_target.y;

				}

			}

			data[component_index] = step_data;

		} // for ( var component_index in data) { 

		component_clone.data = data;
		//console.dir(component_clone);
		return component_clone;
	};

	var move_component = function(p_component, p_move_gap) {

		var x_gap = Number(p_move_gap.x);
		var y_gap = Number(p_move_gap.y);

		var start_name = p_component.start.name;
		var start_x = Number(p_component.start.x) + x_gap;
		var start_y = Number(p_component.start.y) + y_gap;

		var end_name = p_component.end.name;
		var end_x = Number(p_component.end.x) + x_gap;
		var end_y = Number(p_component.end.y) + y_gap;

		var R = {};
		R.start = {};
		R.start.x = start_x;
		R.start.y = start_y;
		R.start.name = start_name;
		R.end = {};
		R.end.x = end_x;
		R.end.y = end_y;
		R.end.name = end_name;
		R.type = p_component.type;

		var data = p_component.data;

		for ( var component_index in data) {

			var step_data = data[component_index];
			if (p_component.type == "path") {

				if (component_index == 0) {

					step_data[1] = Number(step_data[1]) + x_gap;
					step_data[2] = Number(step_data[2]) + y_gap;

				} else {

					if (step_data[0] == "L") {

						step_data[1] = Number(step_data[1]) + x_gap;
						step_data[2] = Number(step_data[2]) + y_gap;

					} else if (step_data[0] == "H") {

						step_data[1] = Number(step_data[1]) + x_gap;

					} else if (step_data[0] == "V") {
						step_data[1] = Number(step_data[1]) + y_gap;

					} else if (step_data[0] == "C") {

						step_data[1] = Number(step_data[1]) + x_gap;
						step_data[2] = Number(step_data[2]) + y_gap;
						step_data[3] = Number(step_data[3]) + x_gap;
						step_data[4] = Number(step_data[4]) + y_gap;
						step_data[5] = Number(step_data[5]) + x_gap;
						step_data[6] = Number(step_data[6]) + y_gap;

					} else if (step_data[0] == "S") {

						step_data[1] = Number(step_data[1]) + x_gap;
						step_data[2] = Number(step_data[2]) + y_gap;
						step_data[3] = Number(step_data[3]) + x_gap;
						step_data[4] = Number(step_data[4]) + y_gap;

					} else if (step_data[0] == "Q") {

						step_data[1] = Number(step_data[1]) + x_gap;
						step_data[2] = Number(step_data[2]) + y_gap;
						step_data[3] = Number(step_data[3]) + x_gap;
						step_data[4] = Number(step_data[4]) + y_gap;

					} else if (step_data[0] == "T") {

						step_data[1] = Number(step_data[1]) + x_gap;
						step_data[2] = Number(step_data[2]) + y_gap;

					} else if (step_data[0] == "A") {
						//console.log("A _____");
					} else if (step_data[0] == "Z") {
						//console.log("A _____");
					}

					//R += " ";
					//R += "z";
				}

			} else if (p_component.type == "line") {

				if (component_index == 0) {

					step_data[1] = Number(step_data[1]) + x_gap;
					step_data[2] = Number(step_data[2]) + y_gap;

				} else {

					step_data[1] = Number(step_data[1]) + x_gap;
					step_data[2] = Number(step_data[2]) + y_gap;

				}

			}

			data[component_index] = step_data;

		} // for ( var component_index in data) { 

		R.data = data;
		return R;

	}

	var flat_component = function(p_component) {
		//console.log("flat_component  ");
		var flat_R = "";

		var data = p_component.data;
		//console.dir(p_component);

		for ( var component_index in data) {

			var step_data = data[component_index];
			//console.log("component_index : " + component_index);
			//console.dir(step_data);

			if (p_component.type == "path") {

				if (component_index == 0) {

					flat_R = "M";
					flat_R += step_data[1];
					flat_R += " ";
					flat_R += step_data[2];
					flat_R += " ";

				} else {

					if (step_data[0] == "L") {

						flat_R += "L";
						flat_R += " ";
						flat_R += step_data[1];
						flat_R += " ";
						flat_R += step_data[2];

					} else if (step_data[0] == "H") {

						flat_R += "H";
						flat_R += " ";
						flat_R += step_data[1];

					} else if (step_data[0] == "V") {

						flat_R += "V";
						flat_R += " ";
						flat_R += step_data[1];

					} else if (step_data[0] == "C") {

						flat_R += "C";
						flat_R += " ";
						flat_R += step_data[1];
						flat_R += " ";
						flat_R += step_data[2];
						flat_R += ",";
						flat_R += step_data[3];
						flat_R += " ";
						flat_R += step_data[4];
						flat_R += ",";
						flat_R += step_data[5];
						flat_R += " ";
						flat_R += step_data[6];

					} else if (step_data[0] == "S") {

						flat_R += "S";
						flat_R += " ";
						flat_R += step_data[1];
						flat_R += " ";
						flat_R += step_data[2];
						flat_R += ",";
						flat_R += step_data[3];
						flat_R += " ";
						flat_R += step_data[4];

					} else if (step_data[0] == "Q") {

						flat_R += "Q";
						flat_R += " ";
						flat_R += step_data[1];
						flat_R += " ";
						flat_R += step_data[2];
						flat_R += ",";
						flat_R += step_data[3];
						flat_R += " ";
						flat_R += step_data[4];

					} else if (step_data[0] == "T") {

						flat_R += "T";
						flat_R += " ";
						flat_R += step_data[1];
						flat_R += " ";
						flat_R += step_data[2];

					} else if (step_data[0] == "A") {
						//console.log("A _____");
					} else if (step_data[0] == "Z") {
						//console.log("A _____");
					}

					//flat_R += " ";
					//flat_R += "z";
				}

			} else if (p_component.type == "line") {

				if (component_index == 0) {

					/* flat_R = [];
					flat_R.push(step_data[1]);
					flat_R.push(step_data[2]); */

					flat_R = "";
					flat_R += step_data[1];
					flat_R += ",";
					flat_R += step_data[2];

				} else {
					/* flat_R.push(step_data[3]);
					flat_R.push(step_data[4]); */

					flat_R = " ";
					flat_R += step_data[1];
					flat_R += ",";
					flat_R += step_data[2];

				}

			}
		}

		//console.log(flat_R);

		return flat_R;

	};

	var zip_model = function(p_dme) {

		// 수치모델에서 포인트 이름과 그 이름이 있는 인덱스를 정리한다. 

		var point_dic = {};

		// 측정항목과 포인트 map을 parsing 한다. 

		var ctrl_data_dic = {};

		var dme = p_dme.component;
		var dme_center = p_dme.center;

		var pure_dme_index = {};
		var pure_dme = [];

		for ( var dme_index in dme) {
			console.log(" zip_model : dme_index");
			console.log(dme_index);

			var dme_item = dme[dme_index];
			var start_point = dme_item.start;
			var end_point = dme_item.end;

			console.dir(dme_item);

			var point_key = start_point.name + end_point.name;

			if (pure_dme_index.hasOwnProperty(point_key)) {
				continue;
			} else {
				pure_dme.push(dme_item);
				pure_dme_index[point_key] = "EXIST";
			}
 

		}
		
		for ( var dme_index in pure_dme) {
			console.log(" zip_model : dme_index");
			console.log(dme_index);
			
			var dme_item = pure_dme[dme_index];
			var start_point = dme_item.start;
			var end_point = dme_item.end;

			console.dir(dme_item);
			

			var point_key = start_point.name + end_point.name;
 
			if (!point_dic.hasOwnProperty(start_point.name)) {

				point_dic[start_point.name] = {};
				point_dic[start_point.name].dme_index = [];
				point_dic[start_point.name].dme_index.push({
					"type" : "start",
					"component_index" : Number(dme_index)
				});

			} else {

				point_dic[start_point.name].dme_index.push({
					"type" : "start",
					"component_index" : Number(dme_index)
				});

			}

			if (!point_dic.hasOwnProperty(end_point.name)) {

				point_dic[end_point.name] = {};
				point_dic[end_point.name].dme_index = [];
				point_dic[end_point.name].dme_index.push({
					"type" : "end",
					"component_index" : Number(dme_index)
				});

			} else {

				point_dic[end_point.name].dme_index.push({
					"type" : "end",
					"component_index" : Number(dme_index)
				});

			}

		}
		

		var zip_dme = {};
		zip_dme.component = pure_dme;
		zip_dme.center = dme_center;
		zip_dme.point_dic = point_dic;
		zip_dme.ratio = Number(p_dme.ratio);

		
		console.dir();
		current_zip_dm = zip_dme;
		draw_model(zip_dme);
		$("#output_dm").val(JSON.stringify(zip_dme));

	};

	var import_control_data = function() {

		/*
		
		 포인트 이동 정의
		 
		                축 : x (X)
		                
		                	방향 : + (오른쪽) , - (왼쪽)
		                
		                축 : y (Y)
		                
		                	방향 : + (아래) ,- (위쪽) 
		                
		                축 : two point (TP)  두점을 지나는 직선의 방정식 
		                
		                        두점이름 : 형식      = 중심점-끝점 (예 P12-P14 )
		                     
		                                    뱡향 : + (중심에서 끝점으로) , - (끝점에서 중심으로)
		                        
		                                    예약어 : svg_center (이미지의 중간 위치 점을 나타낸다.)
		         
		                예)
		                
		                P12를 X축 오른쪽으로 10만큼           	  : P12:X,10
		                P12를 Y축 위로 3만큼                          : P12:Y,3
		                P12를 P12-P14 선에서 끝점으로 4만큼    : P12:TP,P12-P16,4
		                p12를 이미지 중간에서 이미지 밖으로 4만쿰 : p12:tp,svg_center-p12,4
		                
		  		
		 */

		var control_data = $("#input_ctrl").val();

		try {
			current_control_data = JSON.parse(control_data);
		} catch (e) {
			alert("통제 데이터 파싱 오류입니다.");
			return;
		}

		if (current_zip_dm == null) {
			alert("수치 모델이 존재하지 않습니다. ");
			return;
		}
		console.dir(current_control_data);
		console.dir(current_zip_dm);

	};

	var mi_exe = function(p_target, p_mi_direction) {

		//mi_min_1
		//mi_max_1
		//mi_step_1
		//mi_now_1

		var name = $("#mi_name_" + p_target).val();
		var min = $("#mi_min_" + p_target).val();
		var max = $("#mi_max_" + p_target).val();
		var step = $("#mi_step_" + p_target).val();
		var now = $("#mi_now_" + p_target).val();

		//console.dir(current_control_data);
		//console.dir(current_zip_dm);

		console.log("name   : " + name);
		console.log("min   : " + min);
		console.log("max   : " + max);
		console.log("step   : " + step);
		console.log("now   : " + now);

		var op_data = {};
		op_data.name = name;
		op_data.min = min;
		op_data.max = max;
		op_data.step = step;
		op_data.now = now;
		op_data.mi_direction = p_mi_direction;

		if (current_control_data[name]) {

			var cd = current_control_data[name];

			for ( var cd_index in cd) {

				var step_cd = cd[cd_index];
				var step_cd_fist_split = step_cd.split(":");
				var target_point = step_cd_fist_split[0].toUpperCase();
				var target_op = step_cd_fist_split[1].split(",");
				var op_type = target_op[0].toUpperCase();
				var op_direction = target_op[1];

				//console.log(target_point);
				//console.log(target_op);

				op_data.target = target_point;
				op_data.data = target_op;

				if (op_type == "X") {
					op_x_move(op_data, current_zip_dm);
				} else if (op_type == "Y") {
					op_y_move(op_data, current_zip_dm);
				} else if (op_type == "TP") {
					op_tp_move(op_data, current_zip_dm);
				}

			}

			console.dir(current_zip_dm);
			draw_model(current_zip_dm);
			$("#output_dm").val(JSON.stringify(current_zip_dm));

		} else {
			alert("통제 데이터가 존재 하지 않습니다.");
		}

	};

	/*

	       스커트 컨트롤러 데이터 샘플  
	       
	       
	       {
	           "소매": [
	               "p14:tp,+,p13-p14,1",
	               "p13:tp,+,p14-p13,1",
	               "p4:tp,+,p5-p4,1",
	               "p5:tp,+,p4-p5,1"
	           ],
	           "총기장": [
	               "p12:y,-,1",
	               "p22:y,-,1",
	               "p11:y,-,1",
	               "p10:y,-,1",
	               "p9:y,-,1",
	               "p8:y,-,1",
	               "p7:y,-,1",
	               "p6:y,-,1",
	               "p20:y,-,1",
	               "p17:y,-,1",
	               "p18:y,-,1",
	               "p19:y,-,1",
	               "p16:y,+,1",
	               "p1:y,+,1",
	               "p2:y,+,1"
	           ],
	           "팔길이": [
	               "p13:tp,+,p12-p13,1",
	               "p14:tp,+,p15-p14,1",
	               "p4:tp,+,p3-p4,1",
	               "p5:tp,+,p6-p5,1" 
	           ]
	       }
	
	 */

	var op_x_move = function(p_op_data, p_dm) {

		console.log("             OP_X_MOVE START");
		console.dir(p_op_data);
		console.dir(p_dm);

		var move_ratio = p_dm.ratio;
		var op_data = p_op_data.data;
		var op_direction = op_data[1];
		var op_size = Number(op_data[2]);
		var mi_direction = p_op_data.mi_direction;

		if (p_dm.point_dic[p_op_data.target]) {

			var point_index_data = p_dm.point_dic[p_op_data.target].dme_index;

			for ( var pid_index in point_index_data) {

				var component_index = point_index_data[pid_index].component_index;
				var point_start_or_end = point_index_data[pid_index].type;
				var component = p_dm.component[component_index];
				var component_data = component.data;
				var point_data = component[point_start_or_end];

				console
						.log("------- COMPONENT POINT X MOVE  [ BEFORE ]-----------------------------------------------------");
				console.log(" point_name : " + p_op_data.target);
				console.log(" component type : " + component.type);
				console.log(" component index : " + component_index);
				console.log(" point_start_or_end in component : "
						+ point_start_or_end);
				console.log(" point data ");
				console.dir(JSON.stringify(component[point_start_or_end]));
				console.log(" component data ");
				console.dir(JSON.stringify(component.data));

				var move_size = 0;

				if (mi_direction == "+" && op_direction == "+") {
					move_size = Number(p_op_data.step) * move_ratio * op_size;
				} else if (mi_direction == "+" && op_direction == "-") {
					move_size = (Number(p_op_data.step) * move_ratio * op_size)
							* -1;
				} else if (mi_direction == "-" && op_direction == "+") {
					move_size = (Number(p_op_data.step) * move_ratio * op_size)
							* -1;
				} else if (mi_direction == "-" && op_direction == "-") {
					move_size = Number(p_op_data.step) * move_ratio * op_size;
				}

				point_data.x = Number(point_data.x) + move_size;
				point_data.y = Number(point_data.y);

				if (point_start_or_end == "start") {

					var start_data = component_data[0];
					start_data[1] = Number(start_data[1]) + move_size;
					start_data[2] = Number(start_data[2]);

				} else {
					// end 포인트를 조작한다면...

					var end_data = null;

					if (component_data.length == 1) {
						end_data = component_data[0];
					} else {
						end_data = component_data[1];
					}

					if (component.type == "path") {

						if (end_data[0] == "L") { // 라인

							end_data[1] = Number(end_data[1]) + move_size;
							//end_data[2] = Number(end_data[2]) + y_gap;

						} else if (end_data[0] == "H") { // 수평

							end_data[1] = Number(end_data[1]) + move_size;

						} else if (end_data[0] == "V") { // 수직

							//end_data[1] = Number(end_data[1]) + y_gap;

						} else if (end_data[0] == "C") {

							end_data[1] = Number(end_data[1]) + move_size;
							//end_data[2] = Number(end_data[2]) + y_gap;
							end_data[3] = Number(end_data[3]) + move_size;
							//end_data[4] = Number(end_data[4]) + y_gap;
							end_data[5] = Number(end_data[5]) + move_size;
							//end_data[6] = Number(end_data[6]) + y_gap;

						} else if (end_data[0] == "S") {

							end_data[1] = Number(end_data[1]) + move_size;
							//end_data[2] = Number(end_data[2]) + y_gap;
							end_data[3] = Number(end_data[3]) + move_size;
							//end_data[4] = Number(end_data[4]) + y_gap;

						} else if (end_data[0] == "Q") {

							end_data[1] = Number(end_data[1]) + move_size;
							//end_data[2] = Number(end_data[2]) + y_gap;
							end_data[3] = Number(end_data[3]) + move_size;
							//end_data[4] = Number(end_data[4]) + y_gap;

						} else if (end_data[0] == "T") {

							end_data[1] = Number(end_data[1]) + move_size;
							//end_data[2] = Number(end_data[2]) + y_gap;

						} else if (end_data[0] == "A") {
							//console.log("A _____");
						} else if (end_data[0] == "Z") {
							//console.log("A _____");
						}

					} else if (component.type == "line") {

						end_data[1] = Number(end_data[1]) + move_size;
						//end_data[2] = Number(end_data[2]) + y_gap;

					}

				}

				console
						.log("------- COMPONENT POINT X MOVE  [ AFTER ]-----------------------------------------------------");
				console.log(" point_name : " + p_op_data.target);
				console.log(" component type : " + component.type);
				console.log(" component index : " + component_index);
				console.log(" point_start_or_end in component : "
						+ point_start_or_end);
				console.log(" point data ");
				console.dir(JSON.stringify(component[point_start_or_end]));
				console.log(" component data ");
				console.dir(JSON.stringify(component.data));

			}

		} else {
			alert("수치모델에 " + p_op_data.name + " 점이 존재하지 않습니다.");
		}

	};

	var op_y_move = function(p_op_data, p_dm) {

		console.log("             OP_Y_MOVE START");
		console.dir(p_op_data);
		console.dir(p_dm);

		var move_ratio = p_dm.ratio;
		var op_data = p_op_data.data;
		var op_direction = op_data[1];
		var op_size = Number(op_data[2]);
		var mi_direction = p_op_data.mi_direction;

		if (p_dm.point_dic[p_op_data.target]) {

			var point_index_data = p_dm.point_dic[p_op_data.target].dme_index;

			for ( var pid_index in point_index_data) {

				var component_index = point_index_data[pid_index].component_index;
				var point_start_or_end = point_index_data[pid_index].type;
				var component = p_dm.component[component_index];
				var component_data = component.data;
				var point_data = component[point_start_or_end];

				console
						.log("------- COMPONENT POINT Y MOVE  [ BEFORE ]-----------------------------------------------------");
				console.log(" point_name : " + p_op_data.target);
				console.log(" component type : " + component.type);
				console.log(" component index : " + component_index);
				console.log(" point_start_or_end in component : "
						+ point_start_or_end);
				console.log(" point data ");
				console.dir(JSON.stringify(component[point_start_or_end]));
				console.log(" component data ");
				console.dir(JSON.stringify(component.data));

				var move_size = 0;

				if (mi_direction == "+" && op_direction == "+") {
					move_size = Number(p_op_data.step) * move_ratio * op_size;
				} else if (mi_direction == "+" && op_direction == "-") {
					move_size = (Number(p_op_data.step) * move_ratio * op_size)
							* -1;
				} else if (mi_direction == "-" && op_direction == "+") {
					move_size = (Number(p_op_data.step) * move_ratio * op_size)
							* -1;
				} else if (mi_direction == "-" && op_direction == "-") {
					move_size = Number(p_op_data.step) * move_ratio * op_size;
				}

				point_data.x = Number(point_data.x);
				point_data.y = Number(point_data.y) + move_size;

				if (point_start_or_end == "start") {

					var start_data = component_data[0];
					start_data[1] = Number(start_data[1]);
					start_data[2] = Number(start_data[2]) + move_size;

				} else {
					// end 포인트를 조작한다면...

					var end_data = null;

					if (component_data.length == 1) {
						end_data = component_data[0];
					} else {
						end_data = component_data[1];
					}

					if (component.type == "path") {

						if (end_data[0] == "L") { // 라인

							//end_data[1] = Number(end_data[1]) + move_size;
							end_data[2] = Number(end_data[2]) + move_size;

						} else if (end_data[0] == "H") { // 수평

							//end_data[1] = Number(end_data[1]) + move_size;

						} else if (end_data[0] == "V") { // 수직

							end_data[1] = Number(end_data[1]) + move_size;

						} else if (end_data[0] == "C") {

							//end_data[1] = Number(end_data[1]) + x_gap;
							end_data[2] = Number(end_data[2]) + move_size;
							//end_data[3] = Number(end_data[3]) + x_gap;
							end_data[4] = Number(end_data[4]) + move_size;
							//end_data[5] = Number(end_data[5]) + move_size;
							end_data[6] = Number(end_data[6]) + move_size;

						} else if (end_data[0] == "S") {

							//end_data[1] = Number(end_data[1]) + x_gap;
							end_data[2] = Number(end_data[2]) + move_size;
							//end_data[3] = Number(end_data[3]) + move_size;
							end_data[4] = Number(end_data[4]) + move_size;

						} else if (end_data[0] == "Q") {

							//end_data[1] = Number(end_data[1]) + x_gap;
							end_data[2] = Number(end_data[2]) + move_size;
							//end_data[3] = Number(end_data[3]) + move_size;
							end_data[4] = Number(end_data[4]) + move_size;

						} else if (end_data[0] == "T") {

							//end_data[1] = Number(end_data[1]) + move_size;
							end_data[2] = Number(end_data[2]) + move_size;

						} else if (end_data[0] == "A") {
							//console.log("A _____");
						} else if (end_data[0] == "Z") {
							//console.log("A _____");
						}

					} else if (component.type == "line") {

						//end_data[1] = Number(end_data[1]) + move_size;
						end_data[2] = Number(end_data[2]) + move_size;

					}

				}

				console
						.log("------- COMPONENT POINT Y MOVE  [ AFTER ]-----------------------------------------------------");
				console.log(" point_name : " + p_op_data.target);
				console.log(" component type : " + component.type);
				console.log(" component index : " + component_index);
				console.log(" point_start_or_end in component : "
						+ point_start_or_end);
				console.log(" point data ");
				console.dir(JSON.stringify(component[point_start_or_end]));
				console.log(" component data ");
				console.dir(JSON.stringify(component.data));

			}

		} else {
			alert("수치모델에 " + p_op_data.name + " 점이 존재하지 않습니다.");
		}

	};

 
	var op_tp_move = function(p_op_data, p_dm) {

		console.log("             OP_TP_MOVE START");
		console.dir(p_op_data);
		console.dir(p_dm);

		var move_ratio = p_dm.ratio;
		var op_data = p_op_data.data; // ["tp", "+", "p15-p14", "5"]
		var op_direction = op_data[1];
		var op_tp = op_data[2].split("-");
		var op_size = Number(op_data[3]);

		var mi_direction = p_op_data.mi_direction;

		// 시작점과 끝점을 정의 한다. 

		var tp_start_point = null;
		var tp_end_point = null;

		// 시작점
		// svg_center 는 예약어 : template의 중심점

		if (op_tp[0] == "svg_center") {

			tp_start_point = p_dm.center;

		} else {

			if (p_dm.point_dic[op_tp[0].toUpperCase()]) {

				var dme_first_data = p_dm.point_dic[op_tp[0].toUpperCase()].dme_index[0];
				var dme_first_start_or_end = dme_first_data.type;
				var first_component = p_dm.component[dme_first_data.component_index];
				tp_start_point = first_component[dme_first_start_or_end];

			} else {

				alert("point_dic에 tp_start_point가 존재하지 않습니다. "
						+ op_tp[0].toUpperCase());
				return;

			}

		}

		if (op_tp[1] == "svg_center") {
			tp_end_point = p_dm.center;
		} else {

			if (p_dm.point_dic[op_tp[1].toUpperCase()]) {

				var dme_first_data = p_dm.point_dic[op_tp[1].toUpperCase()].dme_index[0];
				var dme_first_start_or_end = dme_first_data.type;
				var first_component = p_dm.component[dme_first_data.component_index];
				tp_end_point = first_component[dme_first_start_or_end];

			} else {

				alert("point_dic에 tp_start_point가 존재하지 않습니다. "
						+ op_tp[1].toUpperCase());
				return;

			}
		}

		var move_size = 0;

		if (mi_direction == "+" && op_direction == "+") {
			move_size = Number(p_op_data.step) * move_ratio * op_size;
		} else if (mi_direction == "+" && op_direction == "-") {
			move_size = (Number(p_op_data.step) * move_ratio * op_size) * -1;
		} else if (mi_direction == "-" && op_direction == "+") {
			move_size = (Number(p_op_data.step) * move_ratio * op_size) * -1;
		} else if (mi_direction == "-" && op_direction == "-") {
			move_size = Number(p_op_data.step) * move_ratio * op_size;
		}

		var tp_moved_point = get_point_by_extension(tp_start_point,
				tp_end_point, move_size);

		//		console.dir(tp_moved_point);
		//		return;

		// 새로 찾은 포인트로 값을 다 업데이트 해준다. 

		if (p_dm.point_dic[p_op_data.target]) {

			var point_index_data = p_dm.point_dic[p_op_data.target].dme_index;

			for ( var pid_index in point_index_data) {

				var component_index = point_index_data[pid_index].component_index;
				var point_start_or_end = point_index_data[pid_index].type;
				var component = p_dm.component[component_index];
				var component_data = component.data;
				var point_data = component[point_start_or_end];

				console
						.log("------- COMPONENT POINT TP MOVE  [ BEFORE ]-----------------------------------------------------");
				console.log(" point_name : " + p_op_data.target);
				console.log(" component type : " + component.type);
				console.log(" component index : " + component_index);
				console.log(" point_start_or_end in component : "
						+ point_start_or_end);
				console.log(" point data ");
				console.dir(JSON.stringify(component[point_start_or_end]));
				console.log(" component data ");
				console.dir(JSON.stringify(component.data));

				point_data.x = Number(tp_moved_point.x);
				point_data.y = Number(tp_moved_point.y);

				if (point_start_or_end == "start") {

					var start_data = component_data[0];
					start_data[1] = Number(tp_moved_point.x);
					start_data[2] = Number(tp_moved_point.y);

				} else {
					// end 포인트를 조작한다면...

					var end_data = null;

					if (component_data.length == 1) {
						end_data = component_data[0];
					} else {
						end_data = component_data[1];
					}

					if (component.type == "path") {

						if (end_data[0] == "L") { // 라인

							end_data[1] = Number(tp_moved_point.x);
							end_data[2] = Number(tp_moved_point.y);

						} else if (end_data[0] == "H") { // 수평

							end_data[1] = Number(tp_moved_point.x);

						} else if (end_data[0] == "V") { // 수직

							end_data[1] = Number(tp_moved_point.y);

						} else if (end_data[0] == "C") {

							//end_data[1] = Number(end_data[1]) + x_gap;
							//end_data[2] = Number(end_data[2]) + y_gap;
							//end_data[3] = Number(end_data[3]) + x_gap;
							//end_data[4] = Number(end_data[4]) + y_gap;
							//end_data[5] = Number(end_data[5]) + move_size;
							//end_data[6] = Number(end_data[6]) + move_size;

							end_data[5] = Number(tp_moved_point.x);
							end_data[6] = Number(tp_moved_point.y);

						} else if (end_data[0] == "S") {

							//end_data[1] = Number(end_data[1]) + x_gap;
							//end_data[2] = Number(end_data[2]) + y_gap;
							//end_data[3] = Number(end_data[3]) + move_size;
							//end_data[4] = Number(end_data[4]) + move_size;

							end_data[3] = Number(tp_moved_point.x);
							end_data[4] = Number(tp_moved_point.y);

						} else if (end_data[0] == "Q") {

							//end_data[1] = Number(end_data[1]) + x_gap;
							//end_data[2] = Number(end_data[2]) + y_gap;
							//end_data[3] = Number(end_data[3]) + move_size;
							//end_data[4] = Number(end_data[4]) + move_size;

							end_data[3] = Number(tp_moved_point.x);
							end_data[4] = Number(tp_moved_point.y);

						} else if (end_data[0] == "T") {

							//end_data[1] = Number(end_data[1]) + move_size;
							//end_data[2] = Number(end_data[2]) + move_size;

							end_data[1] = Number(tp_moved_point.x);
							end_data[2] = Number(tp_moved_point.y);

						} else if (end_data[0] == "A") {
							//console.log("A _____");
						} else if (end_data[0] == "Z") {
							//console.log("A _____");
						}

					} else if (component.type == "line") {

						//end_data[1] = Number(end_data[1]) + move_size;
						//end_data[2] = Number(end_data[2]) + move_size;

						end_data[1] = Number(tp_moved_point.x);
						end_data[2] = Number(tp_moved_point.y);

					}

				}

				console
						.log("------- COMPONENT POINT TP MOVE  [ AFTER ]-----------------------------------------------------");
				console.log(" point_name : " + p_op_data.target);
				console.log(" component type : " + component.type);
				console.log(" component index : " + component_index);
				console.log(" point_start_or_end in component : "
						+ point_start_or_end);
				console.log(" point data ");
				console.dir(JSON.stringify(component[point_start_or_end]));
				console.log(" component data ");
				console.dir(JSON.stringify(component.data));

			}

		} else {
			alert("수치모델에 " + p_op_data.name + " 점이 존재하지 않습니다.");
		}

	};
	
	
	
	
	var find_point_target = null;

	var before_point = function() {
		var point_number = Number($("#point_number").val());

		if (point_number <= 1) {
			alert("이전의  점이 존재하지 않습니다");
			return;
		}

		point_number--;

		$("#point_number").val(point_number);
		
		var dme_index_info = current_zip_dm.point_dic["P"+point_number].dme_index[0];
		var dme_index = dme_index_info.component_index;
		var dme_type = dme_index_info.type;
		var dme = current_zip_dm.component[dme_index_info.component_index];
		var target_point = dme[dme_type];
		
		if (find_point_target != null) {
			find_point_target.hide();
			find_point_target = null;
		}
		find_point_target = MAIN_CANVAS.circle(10).fill('#f06').move(
				Number(target_point.x),
				Number(target_point.y));
		find_point_target.show(); 
		
	};

	var after_point = function() {

		var point_number = $("#point_number").val();
		point_number++;

		$("#point_number").val(point_number);

		var dme_index_info = current_zip_dm.point_dic["P"+point_number].dme_index[0];
		var dme_index = dme_index_info.component_index;
		var dme_type = dme_index_info.type;
		var dme = current_zip_dm.component[dme_index_info.component_index];
		var target_point = dme[dme_type];
		
		if (find_point_target != null) {
			find_point_target.hide();
			find_point_target = null;
		}
		find_point_target = MAIN_CANVAS.circle(10).fill('#f06').move(
				Number(target_point.x),
				Number(target_point.y));
		find_point_target.show(); 
	};

	
</script>
<style>
#MAIN_CANVAS {
	width: 900px;
	height: 900px;
	border: 1px solid black;
}

#maintable {
	width: 100%;
	height: 100%;
}

#back_green {
	background-color: green;
}
</style>
</head>
<body>
 <h1>컨트롤러 시뮬레이터</h1>
 <a href="dynamic_model_builder.html" target="_blank">수치 모델 빌더</a>
 <a href="http://jsbeautifier.org" target="_blank">beautifier</a>
 <a href="http://jsonviewer.stack.hu" target="_blank">jsonviewer</a>
 <a href="http://pressbin.com/tools/urlencode_urldecode/" target="_blank">encoder</a>
 <table id="maintable">
  <tr>
   <td>
    <div>
     X 축 : <input type="text" id="center_x" value="450" /> Y 축 : <input type="text" id="center_y" value="450" /> 비율 : <input type="text" id="center_ratio" value="1.1" />
     <button onclick="move_center();">중심축이동</button>
     <br>
     <button  onclick="before_point();">◁</button> P: <input type="text" id="point_number" value="0" /><button  onclick="after_point();">▷</button> 
    </div>
    <div id="MAIN_CANVAS"></div>
   </td>
   <td>
    <h3>수치모델 입력</h3>
    <button onclick="import_model();">불러들이기</button> <textarea id="input_dm" cols="135" rows="5"></textarea>
    <h3>수치모델 출력</h3> <textarea id="output_dm" cols="135" rows="5"></textarea>
    <h3>controller</h3>
    <button onclick="import_control_data();">통제 데이터 불러들이기</button> <textarea id="input_ctrl" cols="135" rows="10"></textarea>
    <h3>측정항목</h3>
    <div>
     이름 : <input type="text" id="mi_name_1" size="10" size="10" /> min : <input type="text" id="mi_min_1" size="10"> max : <input type="text" id="mi_max_1" size="10"> step : <input type="text" id="mi_step_1" size="10"> now : <input readonly="readonly" type="text" id="mi_now_1" size="10">
     <button onclick="mi_exe('1','+')">△</button>
     <button onclick="mi_exe('1','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_2" size="10" /> min : <input type="text" id="mi_min_2" size="10"> max : <input type="text" id="mi_max_2" size="10"> step : <input type="text" id="mi_step_2" size="10"> now : <input readonly="readonly" type="text" id="mi_now_2" size="10">
     <button onclick="mi_exe('2','+')">△</button>
     <button onclick="mi_exe('2','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_3" size="10" /> min : <input type="text" id="mi_min_3" size="10"> max : <input type="text" id="mi_max_3" size="10"> step : <input type="text" id="mi_step_3" size="10"> now : <input readonly="readonly" type="text" id="mi_now_3" size="10">
     <button onclick="mi_exe('3','+')">△</button>
     <button onclick="mi_exe('3','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_4" size="10" /> min : <input type="text" id="mi_min_4" size="10"> max : <input type="text" id="mi_max_4" size="10"> step : <input type="text" id="mi_step_4" size="10"> now : <input readonly="readonly" type="text" id="mi_now_4" size="10">
     <button onclick="mi_exe('4','+')">△</button>
     <button onclick="mi_exe('4','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_5" size="10" /> min : <input type="text" id="mi_min_5" size="10"> max : <input type="text" id="mi_max_5" size="10"> step : <input type="text" id="mi_step_5" size="10"> now : <input readonly="readonly" type="text" id="mi_now_5" size="10">
     <button onclick="mi_exe('5','+')">△</button>
     <button onclick="mi_exe('5','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_6" size="10" /> min : <input type="text" id="mi_min_6" size="10"> max : <input type="text" id="mi_max_6" size="10"> step : <input type="text" id="mi_step_6" size="10"> now : <input readonly="readonly" type="text" id="mi_now_6" size="10">
     <button onclick="mi_exe('6','+')">△</button>
     <button onclick="mi_exe('6','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_7" size="10" /> min : <input type="text" id="mi_min_7" size="10"> max : <input type="text" id="mi_max_7" size="10"> step : <input type="text" id="mi_step_7" size="10"> now : <input readonly="readonly" type="text" id="mi_now_7" size="10">
     <button onclick="mi_exe('7','+')">△</button>
     <button onclick="mi_exe('7','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_8" size="10" /> min : <input type="text" id="mi_min_8" size="10"> max : <input type="text" id="mi_max_8" size="10"> step : <input type="text" id="mi_step_8" size="10"> now : <input readonly="readonly" type="text" id="mi_now_8" size="10">
     <button onclick="mi_exe('8','+')">△</button>
     <button onclick="mi_exe('8','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_9" size="10" /> min : <input type="text" id="mi_min_9" size="10"> max : <input type="text" id="mi_max_9" size="10"> step : <input type="text" id="mi_step_9" size="10"> now : <input readonly="readonly" type="text" id="mi_now_9" size="10">
     <button onclick="mi_exe('9','+')">△</button>
     <button onclick="mi_exe('9','-')">▽</button>
     <br> 이름 : <input type="text" id="mi_name_10" size="10" /> min : <input type="text" id="mi_min_10" size="10"> max : <input type="text" id="mi_max_10" size="10"> step : <input type="text" id="mi_step_10" size="10"> now : <input readonly="readonly" type="text" id="mi_now_10" size="10">
     <button onclick="mi_exe('10','+')">△</button>
     <button onclick="mi_exe('10','-')">▽</button>
     <br>
    </div>
   </td>
  </tr>
 </table>
</body>
</html>